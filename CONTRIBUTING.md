# Contributing

We love pull requests from everyone. If you wish to contribute, here is how to do it.

If you wish to contribute in any way, first make sure a ticket is open.
The goal is to make sure before you dive into the code that potential changes conform to the goals of the project.
You can either create a ticket or propose on an existing one to take care of it.

Then, fork the repository and clone it onto your machine.

```
git clone git@github.com:your-username/Telemetry.git
```

# Project structure

This project is composed of two parts.

* Core library : located inside the `./src` folder, it is pure C code, not tied to any platform.
* Distributions  : assembled from `./configs`, `./drivers`, `./interfaces` and `./version` and the core lirary.
Each distribution contains platform-specific code.

The interfaces provide a unified way of interacting with Telemetry no matter the platform.
Interfaces are implemented in a header file, and are a collection of functions or a class defining a set of methods.
Currently, there are two different interfaces for the project:
* C
* C++

Mbed and Arduino are using the C++ interface.

Each distribution needs to use one or the other.

# Core library contributions

Inside the project folder, compile the core library and run the tests :

```shell
gradlew installTestsDebugExecutable
cd ./build/install/tests/debug/
tests.bat
```

Make the appropriated changes, add new tests to ensure your additions are running smoothly.

Build and test again. If everything goes well, propose a pull request.

Your changes will be tested automatically on both continuous integration servers.
You can check the tests status on your pull request page.

At this point, your pull request will be reviewed.
Either it will be accepted, or you will receive some feedback before it can be accepted.

# Distributions

Currently, four distributions of the library can be generated:
* Arduino
* ARM Mbed
* pure C
* pure C++

Distributions are assembled from files in different folders in this repository.

All of them include a copy of the core library files located here:
* `./src/crc16/*`
* `./src/framing/*`
* `./src/telemetry/*`

Depending on whether the distribution targets C or C++, it will also contain an interface file from `./interfaces/c/telemetry.h` or `./interfaces/cpp/Telemetry.hpp`

Each distribution will also contain hardware specific code, defined in a dedicated subfolder inside `./drivers`

Each distribution also contains a config file defined in `./configs`. And a version file `./version/telemetry_version.h`

The distribution is then assembled by grabing all files quoted above.

## Create a new distribution

1. Create a new folder with the name of the distribution inside `./drivers/c` or `./drivers/cpp`.
2. Create a `Telemetry.c` or `Telemetry.cpp` file inside the new folder
3. Implement all four hardware specific functions `read` `write` `readable` `writeable` defined in `./src/telemetry/headers/telemetry_utils.h` in the `TM_transport` data structure.
4. Create a new folder with the name of the distribution inside `./configs`. Create a `telemetry_config.h` file.
5. Put any hardware specific configuration in this file.
6. Modify the `build.gradle` file to add a distribution task. Basically, copy the distribution task from Arduino, give it the name of your distribution, and modify it appropriately.
At this point, the distribution can be assembled, but it cannot be tested.

7. In `./mocks`, create a subfolder with the name of your hardware-specific IO library (UART library for instance). Implement a mock, basically a class or collection of functions with the same exact signatures than your actual IO library.
8. In `./integration_tests/c` or `./integration_tests/cpp`, create a folder with the name of your library. Inside this folder, implement your integration tests. Load the file `valid_vectors.csv` generated by the core library (see BUILD.md) and test your interface against each test frame.
9. Send a pull request.

*Note: This process can be rather complex and tedious unless you are very familiar with the library, but it allows to add support for a new platform quite quickly. Open a ticket if you would like to request a new platform but not comfortable with implementing it yourself.*
